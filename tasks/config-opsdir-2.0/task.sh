#!/bin/bash

set -eu

export ROOT_DIR=`pwd`
source $ROOT_DIR/nsx-ci-pipeline/functions/copy_binaries.sh
source $ROOT_DIR/nsx-ci-pipeline/functions/check_versions.sh
source $ROOT_DIR/nsx-ci-pipeline/functions/check_null_variables.sh

export SCRIPT_DIR=$(dirname $0)
export NSX_GEN_OUTPUT_DIR=${ROOT_DIR}/nsx-gen-output
export NSX_GEN_OUTPUT=${NSX_GEN_OUTPUT_DIR}/nsx-gen-out.log
export NSX_GEN_UTIL=${NSX_GEN_OUTPUT_DIR}/nsx_parse_util.sh

if [ -e "${NSX_GEN_OUTPUT}" ]; then
  source ${NSX_GEN_UTIL} ${NSX_GEN_OUTPUT}
else
  echo "Unable to retreive nsx gen output generated from previous nsx-gen-list task!!"
  exit 1
fi

openssl s_client  -servername $NSX_MANAGER_ADDRESS \
                  -connect ${NSX_MANAGER_ADDRESS}:443 \
                  </dev/null 2>/dev/null \
                  | openssl x509 -text \
                  >  /tmp/complete_nsx_manager_cert.log

NSX_MANAGER_CERT_ADDRESS=`cat /tmp/complete_nsx_manager_cert.log \
                        | grep Subject | grep "CN=" \
                        | tr , '\n' | grep 'CN=' \
                        | sed -e 's/.* CN=//' `

echo "Fully qualified domain name for NSX Manager: $NSX_MANAGER_FQDN"
echo "Host name associated with NSX Manager cert: $NSX_MANAGER_CERT_ADDRESS"

# Get all certs from the nsx manager
openssl s_client -host $NSX_MANAGER_ADDRESS \
                 -port 443 -prexit -showcerts \
                 </dev/null 2>/dev/null  \
                 >  /tmp/nsx_manager_all_certs.log

# Get the very last CA cert from the showcerts result
cat /tmp/nsx_manager_all_certs.log \
                  |  awk '/BEGIN /,/END / {print }' \
                  | tail -30                        \
                  |  awk '/BEGIN /,/END / {print }' \
                  >  /tmp/nsx_manager_cacert.log

# Strip newlines and replace them with \r\n
cat /tmp/nsx_manager_cacert.log | tr '\n' '#'| sed -e 's/#/\\n/g'   > /tmp/nsx_manager_edited_cacert.log

#CSV parsing Function for mutiple AZs

NSX_MANAGER_CA_CERTIFICATE=$(cat /tmp/nsx_manager_cacert.log)

function fn_get_azs {
     local azs_csv=$1
     echo $azs_csv | awk -F "," -v quote='"' -v OFS='", "' '$1=$1 {print quote $0 quote}'
}

function fn_get_pg {
  local search_string_net=$1
  local search_string="lsw-${NSX_EDGE_GEN_NAME}-${search_string_net}"
  vwire_pg=$(
  cat ${NSX_GEN_OUTPUT} | \
  grep ${search_string} | \
  grep -v "Effective" | awk '{print$5}' |  grep "virtualwire" | sort -u
  )
  echo $vwire_pg
}

function fn_get_component_static_ips {
  local search_switch=$1
  local search_component=$2
  component_static_ips=$(
  cat ${NSX_GEN_OUTPUT} | \
   grep  "static ips" |
   grep ${search_switch} | \
   grep ${search_component} | \
   awk -F '|' '{print$5}'
  )
  echo $component_static_ips
}

# Check for Errors with obtaining the networks
if [ "$INFRA_VCENTER_NETWORK" == "" \
  -o "$DEPLOYMENT_VCENTER_NETWORK" == "" \
  -o "$SERVICES_VCENTER_NETWORK" == "" \
  -o "$DYNAMIC_SERVICES_VCENTER_NETWORK" == "" ]; then
  echo "Some networks could not be located from NSX!!"
  echo "      INFRASTRUCTURE: $INFRA_VCENTER_NETWORK"
  echo "      ERT DEPLOYMENT: $DEPLOYMENT_VCENTER_NETWORK"
  echo "      SERVICES: $SERVICES_VCENTER_NETWORK"
  echo "      DYNAMIC SERVICES: $DYNAMIC_SERVICES_VCENTER_NETWORK"
  exit 1
fi

iaas_configuration=$(
  jq -n \
  --arg vcenter_host "$VCENTER_HOST" \
  --arg vcenter_username "$VCENTER_USR" \
  --arg vcenter_password "$VCENTER_PWD" \
  --arg datacenter "$VCENTER_DATA_CENTER" \
  --arg disk_type "$VCENTER_DISK_TYPE" \
  --arg ephemeral_datastores_string "$EPHEMERAL_STORAGE_NAMES" \
  --arg persistent_datastores_string "$PERSISTENT_STORAGE_NAMES" \
  --arg bosh_vm_folder "$BOSH_VM_FOLDER" \
  --arg bosh_template_folder "$BOSH_TEMPLATE_FOLDER" \
  --arg bosh_disk_path "$BOSH_DISK_PATH" \
  --arg ssl_verification_enabled false \
  --arg nsx_networking_enabled true \
  --arg nsx_mode "nsx-v" \
  --arg nsx_address "$NSX_MANAGER_FQDN" \
  --arg nsx_username "$NSX_MANAGER_ADMIN_USER" \
  --arg nsx_password "$NSX_MANAGER_ADMIN_PASSWD" \
  --arg nsx_ca_certificate "$NSX_MANAGER_CA_CERTIFICATE" \
  '
  {
    "vcenter_host": $vcenter_host,
    "vcenter_username": $vcenter_username,
    "vcenter_password": $vcenter_password,
    "datacenter": $datacenter,
    "disk_type": $disk_type,
    "ephemeral_datastores_string": $ephemeral_datastores_string,
    "persistent_datastores_string": $persistent_datastores_string,
    "bosh_vm_folder": $bosh_vm_folder,
    "bosh_template_folder": $bosh_template_folder,
    "bosh_disk_path": $bosh_disk_path,
    "ssl_verification_enabled": $ssl_verification_enabled,
    "nsx_networking_enabled": $nsx_networking_enabled,
    "nsx_mode": $nsx_mode,
    "nsx_address": $nsx_address,
    "nsx_username": $nsx_username,
    "nsx_password": $nsx_password,
    "nsx_ca_certificate": $nsx_ca_certificate
  }'
)

az_configuration=$(cat <<-EOF
{
  "availability_zones": [
    {
      "name": "$AZ_1",
      "cluster": "$AZ_1_CLUSTER_NAME",
      "resource_pool": "$AZ_1_RP_NAME"
    },
    {
      "name": "$AZ_2",
      "cluster": "$AZ_2_CLUSTER_NAME",
      "resource_pool": "$AZ_2_RP_NAME"
    },
    {
      "name": "$AZ_3",
      "cluster": "$AZ_3_CLUSTER_NAME",
      "resource_pool": "$AZ_3_RP_NAME"
    }
  ]
}
EOF
)


# MY_INFRA_AZS=$(fn_get_azs $INFRA_NW_AZ)
# MY_DEPLOYMENT_AZS=$(fn_get_azs $DEPLOYMENT_NW_AZ)
# MY_SERVICES_AZS=$(fn_get_azs $SERVICES_NW_AZ)
# MY_DYNAMIC_SERVICES_AZS=$(fn_get_azs $DYNAMIC_SERVICES_NW_AZ)
# MY_ISOZONE_SWITCH_1_AZS=$(fn_get_azs $ISOZONE_SWITCH_1_NW_AZ)


network_configuration=$(
  jq -n \
    --argjson icmp_checks_enabled false \
    --arg infra_network_name "$INFRA_NETWORK_NAME" \
    --arg infra_vcenter_network "$INFRA_VCENTER_NETWORK" \
    --arg infra_network_cidr "$INFRA_NW_CIDR" \
    --arg infra_reserved_ip_ranges "$INFRA_EXCLUDED_RANGE" \
    --arg infra_dns "$INFRA_NW_DNS" \
    --arg infra_gateway "$INFRA_NW_GATEWAY" \
    --arg infra_availability_zones "$INFRA_NW_AZ" \
    --arg deployment_network_name "$DEPLOYMENT_NETWORK_NAME" \
    --arg deployment_vcenter_network "$DEPLOYMENT_VCENTER_NETWORK" \
    --arg deployment_network_cidr "$DEPLOYMENT_NW_CIDR" \
    --arg deployment_reserved_ip_ranges "$DEPLOYMENT_EXCLUDED_RANGE" \
    --arg deployment_dns "$DEPLOYMENT_NW_DNS" \
    --arg deployment_gateway "$DEPLOYMENT_NW_GATEWAY" \
    --arg deployment_availability_zones "$DEPLOYMENT_NW_AZ" \
    --arg services_network_name "$SERVICES_NETWORK_NAME" \
    --arg services_vcenter_network "$SERVICES_VCENTER_NETWORK" \
    --arg services_network_cidr "$SERVICES_NW_CIDR" \
    --arg services_reserved_ip_ranges "$SERVICES_EXCLUDED_RANGE" \
    --arg services_dns "$SERVICES_NW_DNS" \
    --arg services_gateway "$SERVICES_NW_GATEWAY" \
    --arg services_availability_zones "$SERVICES_NW_AZ" \
    --arg dynamic_services_network_name "$DYNAMIC_SERVICES_NETWORK_NAME" \
    --arg dynamic_services_vcenter_network "$DYNAMIC_SERVICES_VCENTER_NETWORK" \
    --arg dynamic_services_network_cidr "$DYNAMIC_SERVICES_NW_CIDR" \
    --arg dynamic_services_reserved_ip_ranges "$DYNAMIC_SERVICES_EXCLUDED_RANGE" \
    --arg dynamic_services_dns "$DYNAMIC_SERVICES_NW_DNS" \
    --arg dynamic_services_gateway "$DYNAMIC_SERVICES_NW_GATEWAY" \
    --arg dynamic_services_availability_zones "$DYNAMIC_SERVICES_NW_AZ" \
    --arg isozone_switch1_network_name "$ISOZONE_SWITCH_1_NETWORK_NAME" \
    --arg isozone_switch1_vcenter_network "$DYNAMIC_SERVICES_VCENTER_NETWORK" \
    --arg isozone_switch1_network_cidr "$ISOZONE_SWITCH_CIDR_1" \
    --arg isozone_switch1_reserved_ip_ranges "$ISOZONE_SWITCH_1_EXCLUDED_RANGE" \
    --arg isozone_switch1_dns "$ISOZONE_SWITCH_1_NW_DNS" \
    --arg isozone_switch1_gateway "$ISOZONE_SWITCH_1_NW_GATEWAY" \
    --arg isozone_switch1_availability_zones "$ISOZONE_SWITCH_1_NW_AZ" \
    '
    {
      "icmp_checks_enabled": $icmp_checks_enabled,
      "networks": [
        {
          "name": $infra_network_name,
          "service_network": false,
          "subnets": [
            {
              "iaas_identifier": $infra_vcenter_network,
              "cidr": $infra_network_cidr,
              "reserved_ip_ranges": $infra_reserved_ip_ranges,
              "dns": $infra_dns,
              "gateway": $infra_gateway,
              "availability_zone_names": ($infra_availability_zones | split(","))
            }
          ]
        },
        {
          "name": $deployment_network_name,
          "service_network": false,
          "subnets": [
            {
              "iaas_identifier": $deployment_vcenter_network,
              "cidr": $deployment_network_cidr,
              "reserved_ip_ranges": $deployment_reserved_ip_ranges,
              "dns": $deployment_dns,
              "gateway": $deployment_gateway,
              "availability_zone_names": ($deployment_availability_zones | split(","))
            }
          ]
        },
        {
          "name": $services_network_name,
          "service_network": false,
          "subnets": [
            {
              "iaas_identifier": $services_vcenter_network,
              "cidr": $services_network_cidr,
              "reserved_ip_ranges": $services_reserved_ip_ranges,
              "dns": $services_dns,
              "gateway": $services_gateway,
              "availability_zone_names": ($services_availability_zones | split(","))
            }
          ]
        },
        {
          "name": $dynamic_services_network_name,
          "service_network": true,
          "subnets": [
            {
              "iaas_identifier": $dynamic_services_vcenter_network,
              "cidr": $dynamic_services_network_cidr,
              "reserved_ip_ranges": $dynamic_services_reserved_ip_ranges,
              "dns": $dynamic_services_dns,
              "gateway": $dynamic_services_gateway,
              "availability_zone_names": ($dynamic_services_availability_zones | split(","))
            }
          ]
        },
        {
          "name": $isozone_switch1_network_name,
          "service_network": false,
          "subnets": [
            {
              "iaas_identifier": $isozone_switch1_vcenter_network,
              "cidr": $isozone_switch1_network_cidr,
              "reserved_ip_ranges": $isozone_switch1_reserved_ip_ranges,
              "dns": $isozone_switch1_dns,
              "gateway": $isozone_switch1_gateway,
              "availability_zone_names": ($isozone_switch1_availability_zones | split(","))
            }
          ]
        }
      ]
    }'
)

director_config=$(cat <<-EOF
{
  "ntp_servers_string": "$OM_NTP_SERVERS",
  "resurrector_enabled": true,
  "max_threads": null,
  "database_type": "internal",
  "blobstore_type": "local",
  "director_hostname": "$OM_DIR_HOSTNAME"
}
EOF
)

security_configuration=$(
  jq -n \
    --arg trusted_certificates "$TRUSTED_CERTIFICATES" \
    '
    {
      "trusted_certificates": $trusted_certificates,
      "vm_password_type": "generate"
    }'
)

network_az_assignment=$(
jq -n \
  --arg infra_availability_zones "$INFRA_NW_AZ" \
  --arg network "$INFRA_NETWORK_NAME" \
  --arg singleton_az "$AZ_SINGLETON" \
  '
  if $singleton_az != "" then
  {
    "singleton_availability_zone": { "name": $singleton_az },
    "network": { "name": $network }
  }
  else
  {
    "singleton_availability_zone": { "name": ($infra_availability_zones | split(",") | .[0]) },
    "network": { "name": $network }
  }
  end
  '
)

echo "Configuring IaaS and Director..."

# om has issues with handling boolean types
# wrapped as string for uknown flags like nsx_networking_enabled
# Error: configuring iaas specific options for bosh tile
# could not execute "configure-bosh":
# could not decode json:
# json: cannot unmarshal string into Go value of type bool
wrapped_iaas_config=$(cat << EOF
{
   "iaas_configuration" : $iaas_configuration
}
EOF
)


wrapped_network_az_assignment=$(cat << EOF
{
   "network_and_az" : $network_az_assignment
}
EOF
)

# So split the configure steps into iaas that uses curl to PUT and normal path for director config
om \
    -t https://$OPS_MGR_HOST \
    -u $OPS_MGR_USR \
    -p $OPS_MGR_PWD \
    -k curl -p '/api/v0/staged/director/properties' \
    -x PUT -d  "$wrapped_iaas_config"
# Check for errors
if [ $? != 0 ]; then
  echo "IaaS configuration failed!!"
  exit 1
fi

om \
    -t https://$OPS_MGR_HOST \
    -u $OPS_MGR_USR \
    -p $OPS_MGR_PWD \
    -k configure-bosh \
    --director-configuration "$director_config"
# Check for errors
if [ $? != 0 ]; then
  echo "Bosh Director configuration failed!!"
  exit 1
fi

om \
    -t https://$OPS_MGR_HOST \
    -u $OPS_MGR_USR \
    -p $OPS_MGR_PWD \
    -k configure-bosh \
    --security-configuration "$security_configuration"
# Check for errors
if [ $? != 0 ]; then
  echo "Bosh Security configuration failed!!"
  exit 1
fi

om \
    -t https://$OPS_MGR_HOST \
    -u $OPS_MGR_USR \
    -p $OPS_MGR_PWD \
    -k curl -p "/api/v0/staged/director/availability_zones" \
    -x PUT -d "$az_configuration"
# Check for errors
if [ $? != 0 ]; then
  echo "Availability Zones configuration failed!!"
  exit 1
fi

om \
    -t https://$OPS_MGR_HOST \
    -u $OPS_MGR_USR \
    -p $OPS_MGR_PWD \
    -k curl -p "/api/v0/staged/director/networks" \
    -x PUT -d "$network_configuration" \
# Check for errors
if [ $? != 0 ]; then
  echo "Networks configuration failed!!"
  exit 1
fi


# Having trouble with om-cli with new network_assignment structure
# that wraps single_az and network inside json structure instead of string
om \
    -t https://$OPS_MGR_HOST \
    -u $OPS_MGR_USR \
    -p $OPS_MGR_PWD \
    -k curl -p "/api/v0/staged/director/network_and_az" \
    -x PUT -d "$wrapped_network_az_assignment" \
# Check for errors
if [ $? != 0 ]; then
  echo "Networks configuration and AZ assignment failed!!"
  exit 1
fi
